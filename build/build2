#!/usr/bin/env bash
# shellcheck disable=SC2001
# shellcheck disable=SC2068
# shellcheck disable=SC2086
# SC2001: GH Runners don't always have variable replacement.
# SC2068: The arrays we're expanding are intended to be re-split.
# SC2068: Prefer not to quote every integer.

LAST_DIR="$PWD"
cd "$(dirname "$0")/.." \
  || return $?
trap 'cd "$LAST_DIR"' EXIT

GLOARGS=$@

inargs() {
  # Nothing is in nothing?
  [ $# -lt 2 ] && return 1
  [ $1 == $2 ] && return 0
  inargs $1 ${@:3}
}
# "Flag in args"
fia() {
  inargs $1 $GLOARGS
}

#
#  Precedence goes highest -> lowest
#  'sh' stands for 'spreadsheet'
#  A row's 'in' expression -> 'out' result
#
# ---------------------------------------------------------------------------------------------------------------------------------------------
#                                                     in                                                                  #        out        #
# ----------------------------------------------------------------------------------------------------------------------- #                   #
#                     negative                    #                                   positive                            #                   #
# ----------------------------------------------- # --------------------------------------------------------------------- #                   #
#           item          #        group          #           item           #        group       #       default         #                   #
#                         #                       #                          #                    #                       #                   #
fia --no-platform-android || fia --no-platform || ! { fia --platform-android || fia --platform-all                     ; }; PLATFORM_ANDROID=$?
fia --no-platform-windows || fia --no-platform || ! { fia --platform-windows || fia --platform-all                     ; }; PLATFORM_WINDOWS=$?
fia   --no-platform-linux || fia --no-platform || ! { fia   --platform-linux || fia --platform-all                     ; };   PLATFORM_LINUX=$?
fia   --no-platform-macos || fia --no-platform || ! { fia   --platform-macos || fia --platform-all                     ; };   PLATFORM_MACOS=$?
fia    --no-platform-this || fia --no-platform || ! { fia    --platform-this || fia --platform-all || ! fia --platform ; };    PLATFORM_THIS=$?
fia     --no-platform-ios || fia --no-platform || ! { fia     --platform-ios || fia --platform-all                     ; };     PLATFORM_IOS=$?
fia    --no-build-release || fia    --no-build || ! { fia    --build-release || fia    --build-all || ! fia    --build ; };    BUILD_RELEASE=$?
fia      --no-build-debug || fia    --no-build || ! { fia      --build-debug || fia    --build-all || ! fia    --build ; };      BUILD_DEBUG=$?
fia      --no-build-bench || fia    --no-build || ! { fia      --build-bench || fia    --build-all || ! fia    --build ; };      BUILD_BENCH=$?
fia       --no-build-test || fia    --no-build || ! { fia       --build-test || fia    --build-all || ! fia    --build ; };       BUILD_TEST=$?
fia        --no-run-bench || fia      --no-run || ! { fia        --run-bench || fia      --run-all || ! fia      --run ; };        RUN_BENCH=$?
fia         --no-run-test || fia      --no-run || ! { fia         --run-test || fia      --run-all || ! fia      --run ; };         RUN_TEST=$?
                                                  ! { fia          --install                                           ; };          INSTALL=$?
                                                  ! { fia            --clean                                           ; };            CLEAN=$?
                                                  ! { fia             --help                                           ; };             HELP=$?
                                                  ! { fia  --inspect-options                                           ; };  INSPECT_OPTIONS=$?
                                                  ! { fia          --verbose                                           ; };          VERBOSE=$?
# ---------------------------------------------------------------------------------------------------------------------------------------------

valid-flags() {
  echo -- --platform-android
  echo -- --platform-windows
  echo -- --platform-linux
  echo -- --platform-macos
  echo -- --platform-this
  echo -- --platform-ios
  echo -- --platform-all
  echo -- --no-platform-android
  echo -- --no-platform-windows
  echo -- --no-platform-linux
  echo -- --no-platform-macos
  echo -- --no-platform-this
  echo -- --no-platform-ios
  echo -- --no-platform
  echo -- --build-release
  echo -- --build-debug
  echo -- --build-bench
  echo -- --build-test
  echo -- --build-all
  echo -- --no-build-release
  echo -- --no-build-debug
  echo -- --no-build-bench
  echo -- --no-build-test
  echo -- --no-build
  echo -- --run-bench
  echo -- --run-test
  echo -- --run-all
  echo -- --no-run-bench
  echo -- --no-run-test
  echo -- --no-run-all
  echo -- --clean
  echo -- --help
  echo -- --inspect-options
  echo -- --verbose
}

flags-are-valid() {
  echo "${GLOARGS[*]}" | tr ' ' '\n' | while read -r given
  do
    valid-flags | grep -cqo -- "$given" || {
      echo "Unexpected option: '$given'"
      return 1
    }
  done
}

inspect-options() {
  echo "PLATFORM_ANDROID=$PLATFORM_ANDROID"
  echo "PLATFORM_WINDOWS=$PLATFORM_WINDOWS"
  echo "  PLATFORM_LINUX=$PLATFORM_LINUX"
  echo "  PLATFORM_MACOS=$PLATFORM_MACOS"
  echo "   PLATFORM_THIS=$PLATFORM_THIS"
  echo "    PLATFORM_IOS=$PLATFORM_IOS"
  echo "   BUILD_RELEASE=$BUILD_RELEASE"
  echo "     BUILD_DEBUG=$BUILD_DEBUG"
  echo "     BUILD_BENCH=$BUILD_BENCH"
  echo "      BUILD_TEST=$BUILD_TEST"
  echo "       RUN_BENCH=$RUN_BENCH"
  echo "        RUN_TEST=$RUN_TEST"
  echo "         INSTALL=$INSTALL"
  echo "           CLEAN=$CLEAN"
  echo "            HELP=$HELP"
}
just-inspect-options() { inspect-options ; exit 0 ; }

help() {
  echo "
$0
  Build the Watcher.
  This file is a collection of shorthands for CMake invocations
  which eases over some platform-specific configuration, cross-
  compilation, and the many, many build targets: unit-tests,
  benches, sanitized builds, debug builds, release builds,
  installation targets, etc, etc, etc.

Usage
  $0 [--help | --clean | [PLATFORM_OPTIONS] [BUILD_OPTIONS] [RUN_OPTIONS]]

Default
  $0 --platform-this --build-all --run-all

Platform Options
$(valid-flags | sed 's/ /\n  /g' | grep platform)

Build Options
$(valid-flags | sed 's/ /\n  /g' | grep build)

Run Options
$(valid-flags | sed 's/ /\n  /g' | grep run)

Examples
  $0 --build-all --no-run-test --run-bench --verbose
  $0 --no-run --build-all --platform-all
  $0 --build-release --install
  $0 --run-bench
  $0 --clean"
}
just-help() { help; exit 0; }

clean() {
  cmd="rm -rf '$PWD/build/out'"
  [ $VERBOSE -eq 1 ] && echo "$cmd"
  eval "$cmd"
}
just-clean() { clean; exit 0; }

# we need to use `tr` here because the bash on
# some github runners reject the ${var,,} syntax
to-uppercase() { echo "$1"   | tr '[:lower:]' '[:upper:]'          ; }
to-lowercase() { echo "$1"   | tr '[:upper:]' '[:lower:]'          ; }
shellstrip()   { tr '\n' ' ' | sed 's/\r\r/\r/g' | sed 's/  */ /g' ; }
all-platforms() {
  echo android
  echo windows
  echo linux
  echo macos
  echo this
  echo ios
}
opt-platforms() {
  [ $PLATFORM_ANDROID -eq 1 ] && echo android
  [ $PLATFORM_WINDOWS -eq 1 ] && echo windows
  [ $PLATFORM_LINUX   -eq 1 ] && echo linux
  [ $PLATFORM_MACOS   -eq 1 ] && echo macos
  [ $PLATFORM_THIS    -eq 1 ] && echo this
  [ $PLATFORM_IOS     -eq 1 ] && echo ios
  return 0
}
out-path-of() {
  [ -n "$1" ] || return 1
  case "$1" in
    android) echo -n "$PWD/build/out/android" ;;
    windows) echo -n "$PWD/build/out/windows" ;;
    linux)   echo -n   "$PWD/build/out/linux" ;;
    macos)   echo -n   "$PWD/build/out/macos" ;;
    this)    echo -n    "$PWD/build/out/this" ;;
    ios)     echo -n     "$PWD/build/out/ios" ;;
    *)                              return 1  ;; esac
  if [ -n "$2" ]
  then echo "/$2"
  else echo
  fi
}
infer-sysname() {
  if [[ -n "$1" && "$1" != this ]]
  then raw=$1
  else raw=$(to-lowercase "$(uname)")
  fi
  case "$raw" in
    darwin*) echo   macos ;;
    linux*)  echo   linux ;;
    mingw*)  echo windows ;;
    *)       echo  "$raw" ;; esac
}
# Unused, but useful ...
# platform-out-paths() {
#   opt-platforms | while read -r platform
#   do path-of "$platform" || return 1
#   done
# }
# bestguess-cmake-generator-of-platform() {
#   case "$(infer-sysname "$(to-lowercase "$1")")" in
#     android) echo "-G 'Unix Makefiles'" ;;
#     windows) echo "-G 'Unix Makefiles'" ;;
#     linux)   echo "-G 'Unix Makefiles'" ;;
#     macos)   echo "-G 'Xcode'"          ;;
#     ios)     echo "-G 'Xcode'"          ;;
#     *)       echo "-G 'Unix Makefiles'" ;; esac ; }
cmake-targetsys-of-platform() {
  # Darwin isn't listed in:
  # https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html
  # So... Keep an eye out. The others should be fine, but WindowsStore
  # might need some tinkering -- Is it really universal?
  case "$(infer-sysname "$(to-lowercase "$1")")" in
    windows) echo WindowsStore ;;
    android) echo Android      ;;
    linux)   echo Linux        ;;
    macos)   echo Darwin       ;;
    ios)     echo iOS          ;;
    *)       return 1          ;; esac
}
all-buildtargets() {
  echo wtr.watcher
  echo wtr.watcher
  echo wtr.bench_watcher
  echo wtr.test_watcher
}
all-base-targets() {
  echo wtr.watcher
  echo wtr.bench_watcher
  echo wtr.test_watcher
}
all-sanitizers() {
  echo asan
  echo msan
  echo tsan
  echo ubsan
}
all-buildcfgs() {
  echo Debug
  echo Release
}
all-buildtargets() {
     all-base-targets | while read -r target
  do echo "$target"
  done
     all-base-targets | while read -r target
  do all-sanitizers   | while read -r sanitizer
  do echo "$target.$sanitizer"
  done
  done
}
all-buildtarget-paths() {
     all-platforms    | while read -r platform
  do all-buildcfgs    | while read -r buildcfg
  do all-buildtargets | while read -r target
  do echo "$(out-path-of "$platform" "$buildcfg")/$target"
  done
  done
  done
}
all-existing-buildtarget-paths() {
  all-buildtarget-paths | while read -r path
  do if [ -f "$path" ]
     then echo "$path"
     fi
  done
}
# Target configs and names from an argument to this program
opt-buildcfgs() {
  [ $BUILD_DEBUG   -eq 1 ] && echo Debug
  [ $BUILD_RELEASE -eq 1 ] && echo Release
}
opt-buildtargets() {
  [ $BUILD_DEBUG   -eq 1 ] && echo wtr.watcher
  [ $BUILD_RELEASE -eq 1 ] && echo wtr.watcher
  [ $BUILD_BENCH   -eq 1 ] && echo wtr.bench_watcher
  [ $BUILD_TEST    -eq 1 ] && echo wtr.test_watcher
}
existing-targets-of-platform() {
  [ -n "$1" ] || return 1 ; platform=$1
  all-buildcfgs \
  | while read -r buildcfg
  # find has no equivalent of -x
  do find \
    "$(out-path-of "$platform" "$buildcfg")" \
    -maxdepth 1 \
    -name 'wtr.*' \
  | while read -r target
  do if [[ -x "$target" && -f "$target" ]]
     then echo "$target"
     fi
  done
  done
}
run-for-each-target-pattern-in-path() {
  [[ -n "$1" && -n "$2" ]] || return 1 ; target_pattern=$1 ; out_path=$2
  find "$out_path" -maxdepth 2 -name "$target_pattern" \
  | while read -r target
  do if test -x "$target"
  then
      echo "running '$target' (from pattern $target_pattern)..."
      "$target" > "$target.result.$(date +"d%Y.%m.%d_t%H.%M.%S").txt"
      echo "ran '$target', ec: $?"
    fi
  done
}
run-for-each-target-pattern-in-this-platform() {
  [ -n "$1" ] || return 1
  target_pattern=$1
  out_path="$(out-path-of this)"
  run-for-each-target-pattern-in-path "$target_pattern" "$out_path"
}
buildcmd-for-each-opt-platform() {
  opt-platforms | while read -r platform
  do opt-buildcfgs | while read -r buildcfg
    # TODO: while read -r target; do ...
    do echo "\
      cmake
        -S '$PWD'
        -B '$(out-path-of "$platform" "$buildcfg")'
        -G 'Unix Makefiles'
        -DCMAKE_BUILD_TYPE='$buildcfg' $(
        [ "$platform" = Android ] \
          && echo "-DCMAKE_ANDROID_NDK='$ANDROID_NDK_HOME'")
        $(targetsysname=$(cmake-targetsys-of-platform "$platform") \
          && echo "-DCMAKE_SYSTEM_NAME='$targetsysname'")
      &&
      cmake
        --build '$(out-path-of "$platform" "$buildcfg")'
        --config '$buildcfg'
      ;" | sed -E 's/^  *//g'
    done
  done
}
build-for-each-opt-platform() {
  [ $VERBOSE -eq 1 ] && buildcmd-for-each-opt-platform
  buildcmd-for-each-opt-platform | shellstrip | bash -e
}
run-matching() {
  while read -r full_pathptrn
  do
    target_basepath=$(dirname "$full_pathptrn")
    target_platform=$(basename "$(dirname "$(dirname "$full_pathptrn")")")
    target_pattern=$(basename "$full_pathptrn")
    [ $VERBOSE -eq 1 ] && echo \
    "Running targets matching '$target_pattern' in '$target_basepath'..."
    existing-targets-of-platform "$target_platform" \
    | while read -r target_binname
      do if echo "$target_binname" | grep -q -- "$target_pattern"
      then
        [ $VERBOSE -eq 1 ] && echo "- $target_binname"
        "$target_binname" \
        | tee "$target_binname.result.$(date +"d%Y.%m.%d_t%H.%M.%S").txt"
      fi
    done
  done
}
run-test()  {
  all-existing-buildtarget-paths | grep this | grep wtr.test_watcher \
  | run-matching
}
run-bench() {
  all-existing-buildtarget-paths | grep this | grep wtr.bench_watcher \
  | run-matching
}

flags-are-valid || { help ; exit 1 ; }
if [ $HELP            -eq 1 ]; then just-help; fi
if [ $CLEAN           -eq 1 ]; then just-clean; fi
if [ $INSPECT_OPTIONS -eq 1 ]; then just-inspect-options; fi
if [ $VERBOSE         -eq 1 ]; then inspect-options; fi
build-for-each-opt-platform
if [ $RUN_TEST        -eq 1 ]; then run-test; fi
if [ $RUN_BENCH       -eq 1 ]; then run-bench; fi

exit 0
