#!/usr/bin/env bash
# shellcheck disable=SC2317
# SC2317 We use eval. These functions aren't unused.
# shellcheck disable=SC2001
# SC2001: GH Runners don't always have variable replacement.

LAST_DIR="$PWD"
cd "$(dirname "$0")/.." \
  || return $?
trap 'cd "$LAST_DIR"' EXIT

HELP="
  Usage
    $0 [--platform= this
      [--no-build-release]
      [--no-build-debug]
      [--no-build-bench]
      [--no-build-test]
      [--no-build]
      [--no-run-bench]
      [--no-run-test]
      [--install]
      [--clean]
    ]

  Arguments
    --platform=PLATFORM:  PLATFORM is one of:
                          this, android, ios, windows, linux, macos

  Options
    --no-build-release:   Skip builds with optimizations
    --no-build-debug:     Skip builds with sanitizers and debug symbols
    --no-build-bench:     Skip builds with benchmarks
    --no-build-test:      Skip builds with sanitizers and unit tests
    --no-build:           Skip building everything
    --no-run-bench:       Skip running the benchmarks
    --no-run-test:        Skip running the unit tests
    --no-run:             Same as --no-run-test --no-run-bench
    --install:            Install the release build
    --clean:              Removes the build/out directory

  Summary
    Build the Watcher.
    This file is a collection of shorthands for CMake invocations
    which eases over some platform-specific configuration.
"
PLATFORM=this
BUILD_RELEASE=1
BUILD_DEBUG=1
BUILD_BENCH=1
BUILD_TEST=1
RUN_BENCH=1
RUN_TEST=1
INSTALL=0
CLEAN=0
HELP=0

OUT_DIR=$PWD/build/out
OUT_PLATFORM_DIR=$OUT_DIR/$PLATFORM

for arg in "$@"; do case "$arg" in
  --platform=*)         PLATFORM="${arg#*=}";shift;;
  --no-build-release)   BUILD_RELEASE=0;;
  --no-build-debug)     BUILD_DEBUG=0;;
  --no-build-bench)     BUILD_BENCH=0;;
  --no-build-test)      BUILD_TEST=0;;
  --no-build)           BUILD_TEST=0;BUILD_BENCH=0;;
  --no-run-bench)       RUN_BENCH=0;;
  --no-run-test)        RUN_TEST=0;;
  --no-run)             RUN_TEST=0;RUN_BENCH=0;;
  --install)            INSTALL=1;;
  --clean)              CLEAN=1;;
  --help)               HELP=1;;
esac; done

# we need to use `tr` here because the bash on
# some github runners reject the ${var,,} syntax
build::to_upper() { echo "$1" | tr '[:lower:]' '[:upper:]'; }
build::to_lower() { echo "$1" | tr '[:upper:]' '[:lower:]'; }

build::get_cmake_system_name_opt_for_platform() {
  if test -n "$1"; then case "$(build::to_lower "$1")" in
    macos)   echo "-DCMAKE_SYSTEM_NAME='macOS'";        return;;
    windows) echo "-DCMAKE_SYSTEM_NAME='WindowsStore'"; return;;
    linux)   echo "-DCMAKE_SYSTEM_NAME='Linux'";        return;;
    android) echo "-DCMAKE_SYSTEM_NAME='Android'";      return;;
    ios)     echo "-DCMAKE_SYSTEM_NAME='iOS'";          return;;
    *)       echo -n '';                                return;;
  esac; fi
}

build::get_cmake_generator_opt_for_platform() {
  if test -n "$1"; then case "$(build::to_lower "$1")" in
    # We use Make for now because we want this
    # to run in github actions without dependencies.
    macos)   echo "-G 'Xcode'";          return;;
    windows) echo "-G 'Unix Makefiles'"; return;;
    linux)   echo "-G 'Unix Makefiles'"; return;;
    android) echo "-G 'Unix Makefiles'"; return;;
    ios)     echo "-G 'Xcode'";          return;;
    *)       echo "-G 'Unix Makefiles'"; return;;
  esac; else
    echo "-G 'Unix Makefiles'"
  fi
}

# We need to pass this in from the command line.
# Most other platform-specifics are within cmake.
build::get_cmake_extra_for_platform() {
  if test -n "$1"; then case "$(build::to_lower "$1")" in
    android)
      echo "-DCMAKE_ANDROID_NDK='$ANDROID_NDK_HOME'"
      return;;
  esac; fi
}

build::get_config_name_for_build_type() {
  if test -n "$1"; then case "$(build::to_lower "$1")" in
    release) echo 'Release'; return;;
    debug)   echo 'Debug';   return;;
    *)       echo 'Debug';   return;;
  esac; else
    echo 'Debug'
  fi
}

build::check::sanitizer_allowed_for::macos() {
  denylist=(
    'msan'
    # 'tsan'
  )
  if [[ "${denylist[*]}" =~ $1 ]]; then return 1; else return 0; fi
}

build::check::sanitizer_allowed_for::windows() {
  # Windows is absurd.
  denylist=(
    'asan'
    'tsan'
    'ubsan'
    'msan'
  )
  if [[ "${denylist[*]}" =~ $1 ]]; then return 1; else return 0; fi
}

build::check::sanitizer_allowed_for::linux() {
  # We want msan but need a way to check for clang
  # because GCC/G++ doesn't have it
  denylist=(
    'msan'
  )
  if [[ "${denylist[*]}" =~ $1 ]]; then return 1; else return 0; fi
}

build::check::sanitizer_allowed_for::android() {
  denylist=(
    'tsan'
    'msan'
  )
  if [[ "${denylist[*]}" =~ $1 ]]; then return 1; else return 0; fi
}

build::check::sanitizer_allowed_for::ios() {
  build::check::sanitizer_allowed_for::macos "$1"
  return $?
}

build::check::sanitizer_allowed_for::this() {
  sanitizer_query="$1"
  discerned_platform_raw="$(build::to_lower "$(uname)")"
  if test "$discerned_platform_raw" = 'darwin'; then
    discerned_platform='macos'
  elif echo "$discerned_platform_raw" | grep -q 'mingw'; then
    discerned_platform='windows'
  else
    discerned_platform="$discerned_platform_raw"
  fi
  eval "build::check::sanitizer_allowed_for::$discerned_platform" "$sanitizer_query"
  return $?
}

build::help() { if test $HELP -eq 1; then echo "$HELP"; exit 0; fi; }

build::clean() { if test $CLEAN -eq 1; then rm -rf "$OUT_DIR"; exit 0; fi; }

build::build() {
  to-on-off() { if test "$1" -gt 0; then echo 'ON'; else echo 'OFF'; fi; }
  cmd="cmake \
    -B '$PWD/build/in' \
    -B '$PWD/build/out/$PLATFORM' \
    $(build::get_cmake_extra_for_platform "$PLATFORM") \
    $(build::get_cmake_generator_opt_for_platform "$PLATFORM") \
    $(build::get_cmake_system_name_opt_for_platform "$PLATFORM") \
    -DWTR_WATCHER_BUILD_ASAN=ON \
    -DWTR_WATCHER_BUILD_MSAN=ON \
    -DWTR_WATCHER_BUILD_UBSAN=ON \
    -DWTR_WATCHER_BUILD_TSAN=ON \
    -DWTR_WATCHER_BUILD_RELEASE=$(to-on-off $BUILD_RELEASE) \
    -DWTR_WATCHER_BUILD_DEBUG=$(to-on-off $BUILD_DEBUG) \
    -DWTR_WATCHER_BUILD_TEST=$(to-on-off $BUILD_TEST) \
    -DWTR_WATCHER_BUILD_BENCH=$(to-on-off $BUILD_BENCH) \
    && cmake \
      --build '$PWD/build/out/$PLATFORM'"
  echo "$cmd" | sed 's/  */ /g'
  if test $((BUILD_TEST + BUILD_BENCH)) -gt 0; then
    eval "$cmd"
  fi
}

build::run::test() {
  if test $RUN_TEST -eq 1; then
    while read -r TEST_PATH; do if test -x "$TEST_PATH"; then
        "$TEST_PATH" \
          | tee "$TEST_PATH.result.$(date +"d%Y.%m.%d_t%H.%M.%S").txt"
      fi
    done <<< "$(\
      find "$PWD/build/out/$PLATFORM" \
        -type f \
        -name "wtr.test_watcher*" \
        -or -name "wtr.test_watcher*.exe"\
          2> /dev/null)"
  fi
}

build::run::bench() {
  if test $RUN_BENCH -eq 1; then
    while read -r t; do
      $t 1>/dev/null "$t.result.$(date +"d%Y.%m.%d_t%H.%M.%S").txt"
      echo "ran $t, ec: $?"
    done <<< "$(\
      find build/out/this -print0 -name 'wtr.test_watcher*' \
      | xargs -I{} -0 bash -c 'test -f {} && echo {}')"
  fi
}

build::run::test_and_bench() {
  # And RUN_$1 -eq 1
  allowed() {
    runopt=$(eval echo "\$RUN_$1")
    re="wtr.$(build::to_lower "$1")_watcher*"
    [[ -x "$2" && -f "$2" && $runopt -eq 1 && "$2" =~ $re ]]
  }
  if test -d build/out; then
    while read -r t; do
      if allowed TEST "$t" || allowed BENCH "$t"; then
        $t 1> "$t.result.$(date +"d%Y.%m.%d_t%H.%M.%S").txt"
        echo "ran $t, ec: $?"
      fi
    done <<< "$(\
      find build/out -print0 -name 'wtr.test_watcher*' -or -name 'wtr.bench_watcher*' \
      | xargs -I{} -0 bash -c 'test -f {} && echo {}')"
  fi
}

build::install() {
  if test $INSTALL -eq 1; then
    release_artifact_dir="$OUT_DIR/this/release"
    maybe_sudo="$(test "$(id -u)" = 0 || echo sudo)"

    test -d "$release_artifact_dir" \
      && eval "$maybe_sudo" cmake --install "$release_artifact_dir"

    return $?
  fi
}

# Other than initializing some variables,
# nothing is done until right here.
build::help "$@" \
&& build::clean "$@" \
&& build::build "$@" \
&& build::run::test_and_bench "$@" \
&& build::install "$@"

